{
  // 泛型函数
  function fn<T>(data: T): T{
    console.log(data)
    return data
  }
  fn<number>(1)
  fn<string>('1')
}


{
  // 泛型接口
  interface Xxx<T> {
    name: T,
    age: number
  }
  const user: Xxx<string> = {
    name: '1',
    age: 18
  }
  console.log(user)
}

// 01、泛型，是确保类型安全的情况下（不丢失类型保护），让函数或接口与其他多种类型配合实现类型复用的统称
// 02、泛型，包括泛型函数、泛型接口、泛型类、以及一些泛型工具
// 03、涉及到泛型就带'<>'，但要区别于TS断言写法中的'<>'
// 04、在TS的函数类型比较宽泛的情况下，让传入到函数的实参类型更加明确，方式有两种
// 04、方式1：指定函数参数比泛型变量为更加具体的类型（直接写在函数参数的类型注解中）
// 04、方式2：添加泛型约束（泛型约束写在函数名称后'<>'的内部）
// 05、数组就是最常见的泛型接口，即数组的泛型接口写法 Array<number> 等同于 number[]
// 06、除了接口interface Xxx<T>和函数function Xxx<>，也可以使用类型别名创建泛型类，即type Xxx<T>
// 06、泛型工具类型，指的是用于统一批量创建新类型的一些工具类型（作用类似于简化类型创建的构造函数）

// N1、泛型函数<>与断言<>的区分
// 01、函数名后的'<>'内部是变量或者为该变量添加是约束条件，它在函数定义时无意义，调用时擦爱确定为某个具体的类型
// 02、断言写法之一的'<>'内部的是更加具体的类型，即断言比TS自动推断出来的更加具体的类型

// N2、不要在react-jsx环境中使用断言的'<>'写法，应该使用'类型 as 值'的写法